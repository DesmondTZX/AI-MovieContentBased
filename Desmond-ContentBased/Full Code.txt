# importing required libraries
import pandas as pd
import numpy as np

from scipy.sparse import csr_matrix
from sklearn.metrics.pairwise import cosine_similarity

from itertools import combinations

# load the dataset
movies_df = pd.read_csv('movies.csv', nrows=62424)
tags_df = pd.read_csv('tags.csv', nrows=62424)

# dropping any unused columns
tags_df = tags_df.drop(['userId', 'timestamp'], axis = 1).reset_index(drop=True)

# check for missing values
movies_df.isnull().sum()

# check for missing values
tags_df.isnull().sum()

# show result
movies_df

# show result
tags_df

# removing null values from tag
tags_df['tag'] = tags_df['tag'].apply(lambda x: '' if pd.isnull(x) else x)

# grouping tags with the same movieId
tags_combined_df = tags_df.groupby('movieId')['tag'].agg(lambda x: '|'.join(x)).reset_index()

# show result
tags_combined_df

# Merge tags with movies
merged = pd.merge(movies_df, tags_combined_df, on='movieId', how='left')

# Fill NaN values in 'tag' column with an empty string
merged['tag'] = merged['tag'].fillna('')

# removing any movies with no tags
merged = merged[merged['tag'] != ""]
merged

# removing any movies with no genres
merged = merged[merged['genres'] != "(no genres listed)"]

# show result
merged[['movieId', 'title', 'genres', 'tag']]

# One-hot encode genres
genres_one_hot = merged['genres'].str.get_dummies()

# One-hot encode tags
tags_one_hot = merged['tag'].str.get_dummies()

# Convert the one-hot encoded dataframes to sparse matrices
genres_sparse = csr_matrix(genres_one_hot.values)
tags_sparse = csr_matrix(tags_one_hot.values)

# Sum one-hot encoded genres and tags
genres_sum = genres_sparse.sum(axis=0)
tags_sum = tags_sparse.sum(axis=0)

print('Genres:')
print(genres_sum)
print('\nTags:')
print(tags_sum)

# sort the samples in alphabetical order
merged = merged.sort_values('movieId')
merged.head(60)

# Combine features (genres and tags) with other movie features
features = pd.concat([merged[['movieId', 'title']], genres_one_hot, tags_one_hot], axis=1)

# Assuming 'features' is a DataFrame containing movie features
features.set_index('movieId', inplace=True)

# Exclude non-numeric columns ('title' in this case) from similarity calculation
numeric_features = features.select_dtypes(include=['number'])
similarities = cosine_similarity(numeric_features)

# Ask the user to input a movie title
user_input = input("Enter a movie title: ")

# Find the index of the movie in the DataFrame that matches the input title
movie_index = features[features['title'].str.lower() == user_input.lower()].index

# Check if the movie exists in the DataFrame
if not movie_index.empty:
    movie_index = movie_index[0]
    if movie_index < len(similarities):
        similar_indices = similarities[movie_index].argsort()[-6:-1][::-1]  # Exclude the movie itself
        similar_movie_ids = numeric_features.iloc[similar_indices].index
        similar_movies = features.loc[similar_movie_ids, 'title']

        # Print recommendations for the input movie title
        print('Recommendations for', user_input)
        print(similar_movies)
    else:
        print("Movie index out of bounds.")
else:
    print("Movie not found.")
    
# Calculate content-based similarity using genres
genres_matrix = merged['genres'].str.get_dummies(sep='|')
genres_similarity = cosine_similarity(genres_matrix)

# Calculate content-based similarity using tags
tags_matrix = merged['tag'].str.get_dummies(sep='|')
tags_similarity = cosine_similarity(tags_matrix)

# Create a mapping between movie titles and indices
title_to_index = {title: idx for idx, title in enumerate(merged['title'])}

# Calculate diversity
pairwise_combinations = list(combinations(merged['title'], 2))
diversity_scores = []
for movie1, movie2 in pairwise_combinations:
    index1 = title_to_index[movie1]
    index2 = title_to_index[movie2]
    diversity_score = 1 - genres_similarity[index1][index2]
    diversity_scores.append(diversity_score)
diversity = sum(diversity_scores) / len(diversity_scores)

# Calculate feature coverage
total_features = set(merged['genres'].str.split('|').sum() + merged['tag'].str.split('|').sum())
recommended_features = set(merged.loc[1:3, 'genres'].str.split('|').sum() + merged.loc[1:3, 'tag'].str.split('|').sum())
feature_coverage = len(recommended_features) / len(total_features)

print(f'Content-Based Similarity (Genres): \n{genres_similarity}\n')
print(f'Content-Based Similarity (Tags): \n{tags_similarity}\n')
print(f'Feature Coverage: {feature_coverage}\n')
print(f'Diversity: {diversity}\n')
